소수 구하기 필요개념.

1.  특정 수 N이 주어졌을 때 단순한 소수판별의 경우에는
    2부터 sqrt(n)까지만 비교하면됨. 
    ex) 36의 경우에
        2 * 18, 3 * 12, 4 * 9, 6 * 6, 9 * 4, .... 이런식으로 대칭을 이루기 때문임.

    code : for(int i = 2; i*i <= N; ++i){....}
            => i*i <= N의 의미는 i<=sqrt(n)을 실현하기 위한 것임.

2.  에라토스 테네스의 채
    특정 수 이내, 특정 구간 이내에서 모든 소수를 찾는 가장 효율적인 알고리즘임.
    방식 => 주어진 구간의 모든 값들을 일단 소수를 둚. 
            가장 작은 소수의 배수들을 구간내의 소수에서 제외시킴.
            ex) 2의 배수를 모두 배제, 3의 배수를 모두 배제, 5의 배수를 모두 배제 ..... 

        code : 특정 수 N 이내일 때,
            prime_bool[0] = prime_bool[1] = false;
            for(int i = 2; i*i<= N; ++i){
                if(prime_bool[i]){
                    for(int j = i*i; j < N; j += i){
                        prime_bool[i] == false;
                    }
                }
            } 

3.  특정 구간[N,M]이 주어졌을 때 그 범위에 존재하는 소수들을 찾기.
    필요한 개념 : N보다 크면서 가장 작은 i의 배수를 구하기
                    => Ceil(N/i)임. int간의 계산해서 이는
                       (N+i-1)/i * i 와 같음.
                    => 또한, Ceil(N/i)와 i * i 중에서 더 큰 값을 선택해야함.

                 code:
                    for(int i = 2; i*i <= M ; ++i){
                        for(int j = max(i*i, (N+i-1)/i * i); j <= M; j += i){
                            prime_bool[j-N] = false;
                        }
                    }